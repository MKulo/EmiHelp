[
  {
    "objectID": "LOGO_Hubi.html",
    "href": "LOGO_Hubi.html",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "Clear the screen and initializing the field\n\nCLEARSCREEN &lt;- function () {\n  rm(list = ls(envir = LOGO), envir = LOGO)\n  new_field(5)\n}\n\n\nCS &lt;- function () {\n  CLEARSCREEN()\n}\n\n\nDon’t show the turtle cursor.\n\nHIDETURTLE &lt;- function () {\n  LOGO$turtle &lt;- FALSE\n  record_path(turtle = LOGO$turtle)\n}\n\n\nHT &lt;- function () {\n  HIDETURTLE()\n}\n\n\nShow the turtle cursor.\n\nSHOWTURTLE &lt;- function () {\n  LOGO$turtle &lt;- TRUE\n  record_path(turtle = LOGO$turtle)\n}\n\n\nST &lt;- function () {\n  SHOWTURTLE()\n}\n\n\nMove forward steps.\n\nFORWARD &lt;- function (step) {\n  angle &lt;- LOGO$path$rad[LOGO$pos] \n  x0 &lt;- LOGO$path$x[LOGO$pos]\n  y0 &lt;- LOGO$path$y[LOGO$pos]\n  \n  max_step &lt;- 1\n  \n  if (abs(step) &gt; max_step) {\n    n_step &lt;- abs(step)%/%(max_step * 1.5) + 1\n    Seq0 &lt;- seq(from = 0, to = 1, by = 1/n_step)\n    Seq0 &lt;- Seq0[-1]\n    steps &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n    steps &lt;- steps * step\n  } else {\n    steps &lt;- step\n  }\n  \n  x1 &lt;- x0 + cos(angle) * steps\n  y1 &lt;- y0 + sin(angle) * steps\n  \n  record_path(x = x1, y = y1, path_color = LOGO$path_color)\n}\n\n\nFD &lt;- function (step) {\n  FORWARD(step)\n}\n\n\nMove back steps.\n\nBACK &lt;- function (steps) {\n  FORWARD(-steps)\n}\n\n\nBK &lt;- function (steps) {\n  BACK(steps)\n}\n\n\nTurn left this many degrees. Negative degrees work too, they’ll turn it right.\n\nLEFT &lt;- function (degs) {\n  LOGO$heading &lt;- LOGO$heading + degs\n  LOGO$heading &lt;- LOGO$heading %% 360\n  record_path(rad = LOGO$heading * pi / 180)\n}\n\n\nLT &lt;- function (degs) {\n  LEFT(degs)\n}\n\n\nTurn right this many degrees.\n\nRIGHT &lt;- function (degs) {\n  LEFT(-degs)\n}\n\n\nRT &lt;- function (degs) {\n  RIGHT(degs)\n}\n\n\nTurn to an absolute heading of degrees.\n\nSETHEADING &lt;- function (deg) {\n  LOGO$heading &lt;- deg\n  record_path(rad = LOGO$heading * pi / 180)\n}\n\n\nSH &lt;- function (deg) {\n  SETHEADING(deg)\n}\n\n\nSet the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\n\nSETPOS &lt;- function (x1, y1) {\n  record_path(x = x1, y = y1, path_color = \"transparent\")\n}\n\n\nSP &lt;- function (x1, y1) {\n  SETPOS(x1, y1)\n}\n\n\nMove back to the home position.\n\nHOME &lt;- function () {\n  SETPOS(x1 = 0, y1 = 0)\n}\n\n\nSet the horizontal position to x.\n\nSETPOSX &lt;- function (x1) {\n  SETPOS(x1, y1 = LOGO$path$y[LOGO$pos])\n}\n\n\nSPX &lt;- function (x1) {\n  SETPOSX(x1)\n}\n\n\nSet the vertical position to y.\n\nSETPOSY &lt;- function (y1) {\n  SETPOS(x1 = LOGO$path$x[LOGO$pos], y1)\n}\n\n\nSPY &lt;- function (y1) {\n  SETPOSY(y1)\n}\n\n\n\n\nSETPATHCOLOR &lt;- function (path_color) {\n  LOGO$path_color &lt;- path_color\n  record_path(path_color = LOGO$path_color)\n}\n\n\nSPC &lt;- function (path_color) {\n  SETPATHCOLOR(path_color)\n}\n\n\n\nSETTURTLECOLOR &lt;- function (turtle_color) {\n  LOGO$turtle_color &lt;- turtle_color\n  record_path(turtle_color = LOGO$turtle_color)\n}\n\n\nSTC &lt;- function (turtle_color) {\n  SETTURTLECOLOR(turtle_color)\n}\n\n\n\nSETNEWCHUNK &lt;- function () {\n  LOGO$chunk &lt;- LOGO$chunk + 1\n  record_path(chunk = LOGO$chunk)\n}\n\n\nSNC &lt;- function () {\n  SETNEWCHUNK()\n}\n\n\n\nUNDOCHUNK &lt;- function () {\n  last_chunk &lt;- max(LOGO$path$chunk)\n  if (last_chunk &gt; 1) {\n    LOGO$path &lt;- LOGO$path[LOGO$path$chunk != last_chunk,]\n  } else {\n    CLEARSCREEN() \n  }\n  \n  LOGO$chunk &lt;- max(LOGO$path$chunk)\n  LOGO$pos &lt;- nrow(LOGO$path)\n  LOGO$heading &lt;- LOGO$path$rad[LOGO$pos] * 180 / pi \n  LOGO$turtle &lt;- LOGO$path$turtle[LOGO$pos]\n  LOGO$turtle_color &lt;- LOGO$path$turtle_color[LOGO$pos]\n  \n  last_pos &lt;- LOGO$pos\n  while (LOGO$path$path_color[last_pos] == \"transparent\" && last_pos &gt; 0) {\n    last_pos &lt;- last_pos - 1\n  }\n  if (last_pos == 0) {\n    LOGO$path_color &lt;- \"blue\"\n  } else {\n    LOGO$path_color &lt;- LOGO$path$path_color[last_pos]\n  }\n  REPLOT()\n}\n\n\nUNDO &lt;- function () {\n  UNDOCHUNK()\n}\n\n\n\nSETSPEED &lt;- function (speed) {\n  speed &lt;- pmax(speed, 1)\n  speed &lt;- round(speed)\n  LOGO$speed &lt;- speed\n}\n\n\nSPEED &lt;- function (speed) {\n  SETSPEED(speed)\n}\n\n\n\nREPLOT &lt;- function (chunk = FALSE) {\n  PLOT(chunk)\n}\n\n\n\nSAVESCREEN &lt;- function (name) {\n  name_gif &lt;- paste0(name, \".gif\")\n  REPLOT()\n  file.copy(from = file.path(tempdir(), \"Logo_Output.gif\"), \n            to = here( name_gif), \n            overwrite = TRUE)\n}\n\n\nSAVE &lt;- function (name) {\n  SAVESCREEN(name)\n}\n\n\n\nQUITLOGO &lt;- function () {\n  if (exists(\"LOGO\", envir = .GlobalEnv)) {\n  rm(LOGO, envir = .GlobalEnv)\n}\n}\n\n\nQUIT &lt;- function () {\n  QUITLOGO()\n}\n\n\n\n\nclean_prompt &lt;- function (Prompt) {\n  Prompt &lt;- gsub(\"([^a-zA-Z0-9])\", \" \\\\1 \", Prompt)\n  Prompt &lt;- gsub(\"\\\\s+\", \" \", Prompt)\n  Prompt &lt;- gsub(\"-\\\\s+(?=\\\\d)\", \"-\", Prompt, perl = TRUE)\n  Prompt &lt;- gsub(\"\\\\s*\\\\.\\\\s*\", \".\", Prompt)\n  Prompt &lt;- gsub(\"\\\\s*_\\\\s*\", \"_\", Prompt)\n  Prompt &lt;- trimws(Prompt)\n  Prompt\n}\n\n\n\nbreakup_String &lt;- function(String) {\n  cl_String &lt;- clean_prompt(String)\n  split_String &lt;- strsplit(cl_String, \" \")[[1]]\n  df &lt;- data.frame(Code = split_String)\n  \n  n_func &lt;- 0\n  df$ID_Func &lt;- rep(0, nrow(df))\n  \n  n_par &lt;- 0\n  df$ID_Par &lt;- rep(0, nrow(df))\n  \n  ID &lt;- 1\n  df$ID_Repeat &lt;- rep(0, nrow(df))\n  \n  brakets &lt;- data.frame(ID = ID,\n                        Status = TRUE,\n                        n = 1)\n  \n  level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n  \n  df$n_Repeat &lt;- rep(1, nrow(df))\n  \n  is_par_braket &lt;- FALSE\n  \n  i &lt;- 1\n  imax &lt;- nrow(df) + 1\n  \n  while ( i &lt; imax ) {\n    \n    if (df$Code[i] == \"[\") {\n        n_par &lt;- n_par + 1\n        is_par_braket &lt;- TRUE\n        i &lt;- i + 1\n        next\n    }\n    \n    if (is_par_braket) {\n      \n      if (df$Code[i] == \"]\") {\n        is_par_braket &lt;- FALSE\n        i &lt;- i + 1\n        next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i])) {\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inLower &lt;- tolower(df$Code[i])\n        if (inLower == \"n\") {\n          df$Code[i] &lt;- paste0(\"(\",inLower,\")\")\n        } else if (inLower %in% colors()) {\n          df$Code[i] &lt;- paste0(\"'\",inLower,\"'\")\n        } else if (exists(inLower)) {\n          df$Code[i] &lt;- inLower\n        }  else {\n          df$Code[i] &lt;- paste0(\"'\",df$Code[i],\"'\")\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n      \n    } else {\n      \n      if (df$Code[i] == \"]\") {\n      brakets$Status[brakets$ID == level] &lt;- FALSE\n      level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n      i &lt;- i + 1\n      next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i]) ) {\n        n_par &lt;- n_par + 1\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inCaps &lt;- toupper(df$Code[i])\n        \n        is_LOGO_func &lt;- exists(inCaps) && is.function(get(inCaps))\n        if (is_LOGO_func) {\n          n_func &lt;- n_func + 1\n          df$Code[i] &lt;- inCaps\n        }\n      \n        is_repeat &lt;- inCaps == \"REPEAT\"\n        if (is_repeat) {\n          n_func &lt;- n_func + 1\n          ID &lt;- ID + 1\n          i = i + 2\n          df$Code[i] &lt;- inCaps\n          brakets &lt;- rbind(brakets,\n                           data.frame(ID = ID, \n                                      Status = TRUE, \n                                      n = round(as.numeric(df$Code[i - 1]))))\n          level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n    }\n\n  }\n  return(df[df$ID_Func != 0,])\n}\n\n\nCodeLine &lt;- \"CS repeat 2 [fd [-pi/n]] sPc [black]\"\ncl_splited &lt;-breakup_String(CodeLine)\ncl_splited\n\n      Code ID_Func ID_Par ID_Repeat n_Repeat\n1       CS       1      0         1        1\n4   REPEAT       2      0         2        2\n5       FD       3      0         2        2\n7        -       3      1         2        2\n8       pi       3      1         2        2\n9        /       3      1         2        2\n10     (n)       3      1         2        2\n13     SPC       4      0         1        1\n15 'black'       4      2         1        1\n\n\n\n\ncreate_Calls &lt;- function (splited) {\n  Calls &lt;- splited %&gt;%\n    group_by(ID_Func, ID_Par) %&gt;%\n    mutate(Func_Par = ifelse(ID_Par &gt; 0,1,0),\n           Code = ifelse(first(ID_Par) &gt; 0, \n                         paste0(Code, collapse = \"\"),\n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, ID_Par, Func_Par, .keep_all = TRUE) %&gt;%\n    \n    group_by(ID_Func, Func_Par) %&gt;%\n    mutate(Code = ifelse(first(Func_Par) &gt; 0, \n                         paste0(Code, collapse = \", \"), \n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, Func_Par, .keep_all = TRUE) %&gt;%\n  \n    group_by(ID_Func) %&gt;%\n    mutate(Code = ifelse(n() &gt; 1,\n                         paste0(Code, collapse = \"(\"),\n                         paste0(Code, \"(\")),\n           Code = paste0(Code, \")\")) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, .keep_all = TRUE) %&gt;%\n    rename(Call = Code, ID = ID_Repeat, n = n_Repeat ) %&gt;%\n    select(Call,ID, n)\n  \n  if ( !any(grepl(\"^UN|SPEED|SAVE|QUIT\", Calls$Call)) ) {\n    first_call &lt;- data.frame(Call = \"SETNEWCHUNK()\", ID = 1, n = 1)\n    last_call &lt;- data.frame(Call = \"PLOT()\", ID = 1, n = 1)\n    Calls &lt;- rbind(first_call, Calls, last_call)\n  } \n  \n  Calls\n}\n\n\nCallshort &lt;- create_Calls(cl_splited)\nCallshort \n\n           Call ID n\n1 SETNEWCHUNK()  1 1\n2          CS()  1 1\n3      REPEAT()  2 2\n4   FD(-pi/(n))  2 2\n5  SPC('black')  1 1\n6        PLOT()  1 1\n\n\n\n\nexpand_Repeats &lt;- function (Calls) {\n  IDmax &lt;- max(Calls$ID)\n  if (IDmax == 1) {\n    return(as.vector(Calls$Call))\n  } \n  while (IDmax &gt; 1){\n    \n    dfm &lt;- data.frame(\n      Call = character(),\n      ID = integer(),\n      n = integer(),\n      stringsAsFactors = FALSE\n      )\n    \n    rID &lt;- range(which(Calls$ID == IDmax))\n    n &lt;- Calls$n[rID[1]] \n    middle &lt;- (rID[1] + 1):rID[2]\n    \n    for (i in 1:n) {\n      dfm_sub &lt;- Calls[middle, ] %&gt;%\n        mutate(Call = gsub(\"\\\\(n\\\\)\", i, Call))\n      dfm &lt;- rbind(dfm,dfm_sub)\n      }\n    dfm$ID &lt;- Calls$ID[rID[1]-1]\n    dfm$n &lt;- Calls$n[rID[1]-1]\n    \n    before &lt;- 1:(rID[1] - 1)\n    dfb &lt;- Calls[before, ]\n    \n    after &lt;- (rID[2] + 1):nrow(Calls)\n    dfa &lt;- Calls[after, ]\n    \n    Calls &lt;- rbind(dfb,dfm,dfa)\n    IDmax &lt;- max(Calls$ID)\n  }\n  return(as.vector(Calls$Call[Calls$Call != \"\"]))\n}\n\n\nCalls &lt;- expand_Repeats(Callshort)\nCalls\n\n[1] \"SETNEWCHUNK()\" \"CS()\"          \"FD(-pi/1)\"     \"FD(-pi/2)\"    \n[5] \"SPC('black')\"  \"PLOT()\"       \n\n\n\n\nrun_prompt &lt;- function (Prompt) {\n  Prompt_splited &lt;- breakup_String(Prompt)\n  Callshort &lt;- create_Calls(Prompt_splited)\n  Calls &lt;- expand_Repeats(Callshort)\n  for (i in 1:length(Calls)){\n    eval(parse(text = as.character(Calls[i])))\n    }\n}\n\n\n\nInitializing the game\n\nnew_field &lt;- function (size) {\n  dir_path &lt;- here(\"LOGO\", \"temp\")\n  chunk &lt;- 1\n  pos &lt;- 2\n  heading &lt;- 0\n  turtle &lt;- TRUE\n  turtle_color &lt;- \"red\"\n  path_color &lt;- \"blue\"\n  speed &lt;- 50\n  path &lt;- data.frame(\n    chunk = rep(1, pos),\n    x = rep(0, pos),\n    y = rep(0, pos),\n    rad = rep(0, pos),\n    path_color = rep(\"transparent\", pos),\n    turtle = c(FALSE, rep(turtle, pos - 1)),\n    turtle_color = rep(turtle_color, pos),\n    stringsAsFactors = FALSE\n  )\n  \n  LOGO$field_name = \"LOGO\"\n  LOGO$field_dir = here()\n  LOGO$size = abs(size)\n  LOGO$chunk = chunk\n  LOGO$pos = pos\n  LOGO$heading = heading\n  LOGO$turtle = turtle\n  LOGO$turtle_color = turtle_color\n  LOGO$path_color = path_color\n  LOGO$speed = speed\n  LOGO$path = path\n}\n\n\n\n record_path &lt;- function (chunk = NULL,\n                          x = NULL, \n                          y = NULL, \n                          rad = NULL, \n                          path_color = NULL, \n                          turtle = NULL,\n                          turtle_color = NULL) {\n   \n   n &lt;- max(length(x),1)\n   template &lt;- LOGO$path[LOGO$pos, ]\n   \n   if (n &gt; 1) {\n     newrows &lt;- template[rep(1,n), ]\n     new_pos &lt;- LOGO$pos + (1:n)\n   } else {\n     newrows &lt;- template\n     new_pos &lt;- LOGO$pos + 1\n   }\n   \n   \n   if (!is.null(chunk)) newrows$chunk &lt;- chunk\n   if (!is.null(x)) newrows$x &lt;- x\n   if (!is.null(y)) newrows$y &lt;- y\n   if (!is.null(rad)) newrows$rad &lt;- rad\n   if (!is.null(path_color)) newrows$path_color &lt;- path_color\n   if (!is.null(turtle)) newrows$turtle &lt;- turtle\n   if (!is.null(turtle_color)) newrows$turtle_color &lt;- turtle_color\n   \n   LOGO$path[new_pos,] &lt;- newrows\n   LOGO$pos &lt;- nrow(LOGO$path)\n}\n\n\n\n\nplot_field &lt;- function (stat) {\n  maxpath &lt;- ceiling(max(abs(LOGO$path[1:stat,c(\"x\",\"y\")])) * 1.11)\n  LOGO$size &lt;- max(c(LOGO$size, maxpath), na.rm = TRUE)\n\n  par(mar = c(0, 0, 0, 0),\n      xaxs = \"i\", yaxs = \"i\")\n  plot.new()\n  plot.window(xlim = c(-LOGO$size, LOGO$size),\n              ylim = c(-LOGO$size, LOGO$size),\n              asp = 1)\n  box()\n}\n\n\n\nplot_path &lt;- function (stat) {\n  if (stat &gt; 1) {\n    path_stat &lt;- LOGO$path[1:stat,]\n    segments(x0 = path_stat$x[-stat], \n             y0 = path_stat$y[-stat],\n             x1 = path_stat$x[-1], \n             y1 = path_stat$y[-1],\n             col = path_stat$path_color[-1], \n             lwd = 2)\n  }\n}\n\n\n\nplot_turtle &lt;- function (stat) {\n  show &lt;-  LOGO$path$turtle[stat]\n  if (show) {\n    pos_x &lt;- LOGO$path$x[stat]\n    pos_y &lt;- LOGO$path$y[stat]\n    symbols(x = pos_x,\n            y = pos_y,\n            circles = 0.02 * LOGO$size,\n            inches = FALSE,\n            fg = NA,\n            bg = LOGO$path$turtle_color[stat],\n            add = TRUE)\n    arrow_length &lt;- 0.1 * LOGO$size\n    angle &lt;- LOGO$path$rad[stat]\n    arrows(pos_x,\n           pos_y,\n           pos_x + cos(angle) * arrow_length,\n           pos_y + sin(angle) * arrow_length,\n           col = LOGO$path$turtle_color[stat],\n           code = 2,\n           length = 0.1,\n           angle = 20,\n           lwd = 2)\n  }\n}\n\n\n\nplot_stat &lt;- function (stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(LOGO$path)\n  \n  tmpfile &lt;- tempfile(fileext = \".png\")\n  png(filename = tmpfile, width = 600, height = 600, res = 150)\n  \n  plot_field(stat)\n  plot_path(stat)\n  plot_turtle(stat)\n  \n  dev.off()\n  img &lt;- image_read(tmpfile)\n  \n  unlink(tmpfile)\n\n  img\n\n}\n\n\n\nPLOT &lt;- function (chunk = TRUE) {\n  invisible(NULL)\n  \n  if (chunk) {\n    Range &lt;- range(which(LOGO$path$chunk == max(LOGO$chunk)))\n    rmin &lt;- max(2,Range[1])\n    rmax &lt;- Range[2]\n    } else {\n      rmin &lt;- 2\n      rmax &lt;- nrow(LOGO$path)\n    }\n  \n  step &lt;- LOGO$speed/(rmax-rmin)\n  step &lt;- pmin(pmax(step, 1/200), 1)\n  Seq0 &lt;- seq(from = 0, to = 1, by = step)\n  plot_seq &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  plot_seq &lt;- (rmax - rmin) * plot_seq + rmin\n  plot_seq &lt;- round(plot_seq)\n  plot_seq &lt;- unique(plot_seq)\n  \n  img_list &lt;- lapply(plot_seq, function(i) plot_stat(i))\n  Logo_Output &lt;- image_animate(image_join(img_list), \n                             fps = 10, loop = 1,\n                             optimize = TRUE) \n  \n  gif_path &lt;- file.path(tempdir(), \"Logo_Output.gif\")\n  image_write(Logo_Output, path = gif_path)\n  \n  print(Logo_Output)\n}\n\n\n\nrun_LOGO &lt;- function(string) {\n  if (!exists(\"LOGO\", envir = .GlobalEnv)) {\n    assign(\"LOGO\", new.env(), envir = .GlobalEnv)\n    LOGO &lt;- get(\"LOGO\", envir = .GlobalEnv)\n    new_field(5)\n  } else {\n    LOGO &lt;- get(\"LOGO\", envir = .GlobalEnv)\n  }\n  run_prompt(string)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#basic-commands",
    "href": "LOGO_Hubi.html#basic-commands",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "Clear the screen and initializing the field\n\nCLEARSCREEN &lt;- function () {\n  rm(list = ls(envir = LOGO), envir = LOGO)\n  new_field(5)\n}\n\n\nCS &lt;- function () {\n  CLEARSCREEN()\n}\n\n\nDon’t show the turtle cursor.\n\nHIDETURTLE &lt;- function () {\n  LOGO$turtle &lt;- FALSE\n  record_path(turtle = LOGO$turtle)\n}\n\n\nHT &lt;- function () {\n  HIDETURTLE()\n}\n\n\nShow the turtle cursor.\n\nSHOWTURTLE &lt;- function () {\n  LOGO$turtle &lt;- TRUE\n  record_path(turtle = LOGO$turtle)\n}\n\n\nST &lt;- function () {\n  SHOWTURTLE()\n}\n\n\nMove forward steps.\n\nFORWARD &lt;- function (step) {\n  angle &lt;- LOGO$path$rad[LOGO$pos] \n  x0 &lt;- LOGO$path$x[LOGO$pos]\n  y0 &lt;- LOGO$path$y[LOGO$pos]\n  \n  max_step &lt;- 1\n  \n  if (abs(step) &gt; max_step) {\n    n_step &lt;- abs(step)%/%(max_step * 1.5) + 1\n    Seq0 &lt;- seq(from = 0, to = 1, by = 1/n_step)\n    Seq0 &lt;- Seq0[-1]\n    steps &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n    steps &lt;- steps * step\n  } else {\n    steps &lt;- step\n  }\n  \n  x1 &lt;- x0 + cos(angle) * steps\n  y1 &lt;- y0 + sin(angle) * steps\n  \n  record_path(x = x1, y = y1, path_color = LOGO$path_color)\n}\n\n\nFD &lt;- function (step) {\n  FORWARD(step)\n}\n\n\nMove back steps.\n\nBACK &lt;- function (steps) {\n  FORWARD(-steps)\n}\n\n\nBK &lt;- function (steps) {\n  BACK(steps)\n}\n\n\nTurn left this many degrees. Negative degrees work too, they’ll turn it right.\n\nLEFT &lt;- function (degs) {\n  LOGO$heading &lt;- LOGO$heading + degs\n  LOGO$heading &lt;- LOGO$heading %% 360\n  record_path(rad = LOGO$heading * pi / 180)\n}\n\n\nLT &lt;- function (degs) {\n  LEFT(degs)\n}\n\n\nTurn right this many degrees.\n\nRIGHT &lt;- function (degs) {\n  LEFT(-degs)\n}\n\n\nRT &lt;- function (degs) {\n  RIGHT(degs)\n}\n\n\nTurn to an absolute heading of degrees.\n\nSETHEADING &lt;- function (deg) {\n  LOGO$heading &lt;- deg\n  record_path(rad = LOGO$heading * pi / 180)\n}\n\n\nSH &lt;- function (deg) {\n  SETHEADING(deg)\n}\n\n\nSet the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\n\nSETPOS &lt;- function (x1, y1) {\n  record_path(x = x1, y = y1, path_color = \"transparent\")\n}\n\n\nSP &lt;- function (x1, y1) {\n  SETPOS(x1, y1)\n}\n\n\nMove back to the home position.\n\nHOME &lt;- function () {\n  SETPOS(x1 = 0, y1 = 0)\n}\n\n\nSet the horizontal position to x.\n\nSETPOSX &lt;- function (x1) {\n  SETPOS(x1, y1 = LOGO$path$y[LOGO$pos])\n}\n\n\nSPX &lt;- function (x1) {\n  SETPOSX(x1)\n}\n\n\nSet the vertical position to y.\n\nSETPOSY &lt;- function (y1) {\n  SETPOS(x1 = LOGO$path$x[LOGO$pos], y1)\n}\n\n\nSPY &lt;- function (y1) {\n  SETPOSY(y1)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#gimmicks",
    "href": "LOGO_Hubi.html#gimmicks",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "SETPATHCOLOR &lt;- function (path_color) {\n  LOGO$path_color &lt;- path_color\n  record_path(path_color = LOGO$path_color)\n}\n\n\nSPC &lt;- function (path_color) {\n  SETPATHCOLOR(path_color)\n}\n\n\n\nSETTURTLECOLOR &lt;- function (turtle_color) {\n  LOGO$turtle_color &lt;- turtle_color\n  record_path(turtle_color = LOGO$turtle_color)\n}\n\n\nSTC &lt;- function (turtle_color) {\n  SETTURTLECOLOR(turtle_color)\n}\n\n\n\nSETNEWCHUNK &lt;- function () {\n  LOGO$chunk &lt;- LOGO$chunk + 1\n  record_path(chunk = LOGO$chunk)\n}\n\n\nSNC &lt;- function () {\n  SETNEWCHUNK()\n}\n\n\n\nUNDOCHUNK &lt;- function () {\n  last_chunk &lt;- max(LOGO$path$chunk)\n  if (last_chunk &gt; 1) {\n    LOGO$path &lt;- LOGO$path[LOGO$path$chunk != last_chunk,]\n  } else {\n    CLEARSCREEN() \n  }\n  \n  LOGO$chunk &lt;- max(LOGO$path$chunk)\n  LOGO$pos &lt;- nrow(LOGO$path)\n  LOGO$heading &lt;- LOGO$path$rad[LOGO$pos] * 180 / pi \n  LOGO$turtle &lt;- LOGO$path$turtle[LOGO$pos]\n  LOGO$turtle_color &lt;- LOGO$path$turtle_color[LOGO$pos]\n  \n  last_pos &lt;- LOGO$pos\n  while (LOGO$path$path_color[last_pos] == \"transparent\" && last_pos &gt; 0) {\n    last_pos &lt;- last_pos - 1\n  }\n  if (last_pos == 0) {\n    LOGO$path_color &lt;- \"blue\"\n  } else {\n    LOGO$path_color &lt;- LOGO$path$path_color[last_pos]\n  }\n  REPLOT()\n}\n\n\nUNDO &lt;- function () {\n  UNDOCHUNK()\n}\n\n\n\nSETSPEED &lt;- function (speed) {\n  speed &lt;- pmax(speed, 1)\n  speed &lt;- round(speed)\n  LOGO$speed &lt;- speed\n}\n\n\nSPEED &lt;- function (speed) {\n  SETSPEED(speed)\n}\n\n\n\nREPLOT &lt;- function (chunk = FALSE) {\n  PLOT(chunk)\n}\n\n\n\nSAVESCREEN &lt;- function (name) {\n  name_gif &lt;- paste0(name, \".gif\")\n  REPLOT()\n  file.copy(from = file.path(tempdir(), \"Logo_Output.gif\"), \n            to = here( name_gif), \n            overwrite = TRUE)\n}\n\n\nSAVE &lt;- function (name) {\n  SAVESCREEN(name)\n}\n\n\n\nQUITLOGO &lt;- function () {\n  if (exists(\"LOGO\", envir = .GlobalEnv)) {\n  rm(LOGO, envir = .GlobalEnv)\n}\n}\n\n\nQUIT &lt;- function () {\n  QUITLOGO()\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#parsing-prompts",
    "href": "LOGO_Hubi.html#parsing-prompts",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "clean_prompt &lt;- function (Prompt) {\n  Prompt &lt;- gsub(\"([^a-zA-Z0-9])\", \" \\\\1 \", Prompt)\n  Prompt &lt;- gsub(\"\\\\s+\", \" \", Prompt)\n  Prompt &lt;- gsub(\"-\\\\s+(?=\\\\d)\", \"-\", Prompt, perl = TRUE)\n  Prompt &lt;- gsub(\"\\\\s*\\\\.\\\\s*\", \".\", Prompt)\n  Prompt &lt;- gsub(\"\\\\s*_\\\\s*\", \"_\", Prompt)\n  Prompt &lt;- trimws(Prompt)\n  Prompt\n}\n\n\n\nbreakup_String &lt;- function(String) {\n  cl_String &lt;- clean_prompt(String)\n  split_String &lt;- strsplit(cl_String, \" \")[[1]]\n  df &lt;- data.frame(Code = split_String)\n  \n  n_func &lt;- 0\n  df$ID_Func &lt;- rep(0, nrow(df))\n  \n  n_par &lt;- 0\n  df$ID_Par &lt;- rep(0, nrow(df))\n  \n  ID &lt;- 1\n  df$ID_Repeat &lt;- rep(0, nrow(df))\n  \n  brakets &lt;- data.frame(ID = ID,\n                        Status = TRUE,\n                        n = 1)\n  \n  level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n  \n  df$n_Repeat &lt;- rep(1, nrow(df))\n  \n  is_par_braket &lt;- FALSE\n  \n  i &lt;- 1\n  imax &lt;- nrow(df) + 1\n  \n  while ( i &lt; imax ) {\n    \n    if (df$Code[i] == \"[\") {\n        n_par &lt;- n_par + 1\n        is_par_braket &lt;- TRUE\n        i &lt;- i + 1\n        next\n    }\n    \n    if (is_par_braket) {\n      \n      if (df$Code[i] == \"]\") {\n        is_par_braket &lt;- FALSE\n        i &lt;- i + 1\n        next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i])) {\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inLower &lt;- tolower(df$Code[i])\n        if (inLower == \"n\") {\n          df$Code[i] &lt;- paste0(\"(\",inLower,\")\")\n        } else if (inLower %in% colors()) {\n          df$Code[i] &lt;- paste0(\"'\",inLower,\"'\")\n        } else if (exists(inLower)) {\n          df$Code[i] &lt;- inLower\n        }  else {\n          df$Code[i] &lt;- paste0(\"'\",df$Code[i],\"'\")\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n      \n    } else {\n      \n      if (df$Code[i] == \"]\") {\n      brakets$Status[brakets$ID == level] &lt;- FALSE\n      level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n      i &lt;- i + 1\n      next\n      }\n      \n      if ( !grepl(\"[A-Za-z]\", df$Code[i]) ) {\n        n_par &lt;- n_par + 1\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Par[i] &lt;- n_par\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      } else {\n        inCaps &lt;- toupper(df$Code[i])\n        \n        is_LOGO_func &lt;- exists(inCaps) && is.function(get(inCaps))\n        if (is_LOGO_func) {\n          n_func &lt;- n_func + 1\n          df$Code[i] &lt;- inCaps\n        }\n      \n        is_repeat &lt;- inCaps == \"REPEAT\"\n        if (is_repeat) {\n          n_func &lt;- n_func + 1\n          ID &lt;- ID + 1\n          i = i + 2\n          df$Code[i] &lt;- inCaps\n          brakets &lt;- rbind(brakets,\n                           data.frame(ID = ID, \n                                      Status = TRUE, \n                                      n = round(as.numeric(df$Code[i - 1]))))\n          level &lt;- brakets$ID[max(which(brakets$Status == TRUE))]\n        }\n        df$ID_Func[i] &lt;- n_func\n        df$ID_Repeat[i] &lt;- brakets$ID[brakets$ID == level]\n        df$n_Repeat[i] &lt;- brakets$n[brakets$ID == level]\n        i &lt;- i + 1\n        next\n      }\n    }\n\n  }\n  return(df[df$ID_Func != 0,])\n}\n\n\nCodeLine &lt;- \"CS repeat 2 [fd [-pi/n]] sPc [black]\"\ncl_splited &lt;-breakup_String(CodeLine)\ncl_splited\n\n      Code ID_Func ID_Par ID_Repeat n_Repeat\n1       CS       1      0         1        1\n4   REPEAT       2      0         2        2\n5       FD       3      0         2        2\n7        -       3      1         2        2\n8       pi       3      1         2        2\n9        /       3      1         2        2\n10     (n)       3      1         2        2\n13     SPC       4      0         1        1\n15 'black'       4      2         1        1\n\n\n\n\ncreate_Calls &lt;- function (splited) {\n  Calls &lt;- splited %&gt;%\n    group_by(ID_Func, ID_Par) %&gt;%\n    mutate(Func_Par = ifelse(ID_Par &gt; 0,1,0),\n           Code = ifelse(first(ID_Par) &gt; 0, \n                         paste0(Code, collapse = \"\"),\n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, ID_Par, Func_Par, .keep_all = TRUE) %&gt;%\n    \n    group_by(ID_Func, Func_Par) %&gt;%\n    mutate(Code = ifelse(first(Func_Par) &gt; 0, \n                         paste0(Code, collapse = \", \"), \n                         Code)) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, Func_Par, .keep_all = TRUE) %&gt;%\n  \n    group_by(ID_Func) %&gt;%\n    mutate(Code = ifelse(n() &gt; 1,\n                         paste0(Code, collapse = \"(\"),\n                         paste0(Code, \"(\")),\n           Code = paste0(Code, \")\")) %&gt;%\n    ungroup() %&gt;%\n    distinct(Code, ID_Func, .keep_all = TRUE) %&gt;%\n    rename(Call = Code, ID = ID_Repeat, n = n_Repeat ) %&gt;%\n    select(Call,ID, n)\n  \n  if ( !any(grepl(\"^UN|SPEED|SAVE|QUIT\", Calls$Call)) ) {\n    first_call &lt;- data.frame(Call = \"SETNEWCHUNK()\", ID = 1, n = 1)\n    last_call &lt;- data.frame(Call = \"PLOT()\", ID = 1, n = 1)\n    Calls &lt;- rbind(first_call, Calls, last_call)\n  } \n  \n  Calls\n}\n\n\nCallshort &lt;- create_Calls(cl_splited)\nCallshort \n\n           Call ID n\n1 SETNEWCHUNK()  1 1\n2          CS()  1 1\n3      REPEAT()  2 2\n4   FD(-pi/(n))  2 2\n5  SPC('black')  1 1\n6        PLOT()  1 1\n\n\n\n\nexpand_Repeats &lt;- function (Calls) {\n  IDmax &lt;- max(Calls$ID)\n  if (IDmax == 1) {\n    return(as.vector(Calls$Call))\n  } \n  while (IDmax &gt; 1){\n    \n    dfm &lt;- data.frame(\n      Call = character(),\n      ID = integer(),\n      n = integer(),\n      stringsAsFactors = FALSE\n      )\n    \n    rID &lt;- range(which(Calls$ID == IDmax))\n    n &lt;- Calls$n[rID[1]] \n    middle &lt;- (rID[1] + 1):rID[2]\n    \n    for (i in 1:n) {\n      dfm_sub &lt;- Calls[middle, ] %&gt;%\n        mutate(Call = gsub(\"\\\\(n\\\\)\", i, Call))\n      dfm &lt;- rbind(dfm,dfm_sub)\n      }\n    dfm$ID &lt;- Calls$ID[rID[1]-1]\n    dfm$n &lt;- Calls$n[rID[1]-1]\n    \n    before &lt;- 1:(rID[1] - 1)\n    dfb &lt;- Calls[before, ]\n    \n    after &lt;- (rID[2] + 1):nrow(Calls)\n    dfa &lt;- Calls[after, ]\n    \n    Calls &lt;- rbind(dfb,dfm,dfa)\n    IDmax &lt;- max(Calls$ID)\n  }\n  return(as.vector(Calls$Call[Calls$Call != \"\"]))\n}\n\n\nCalls &lt;- expand_Repeats(Callshort)\nCalls\n\n[1] \"SETNEWCHUNK()\" \"CS()\"          \"FD(-pi/1)\"     \"FD(-pi/2)\"    \n[5] \"SPC('black')\"  \"PLOT()\"       \n\n\n\n\nrun_prompt &lt;- function (Prompt) {\n  Prompt_splited &lt;- breakup_String(Prompt)\n  Callshort &lt;- create_Calls(Prompt_splited)\n  Calls &lt;- expand_Repeats(Callshort)\n  for (i in 1:length(Calls)){\n    eval(parse(text = as.character(Calls[i])))\n    }\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#helper-functions",
    "href": "LOGO_Hubi.html#helper-functions",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "Initializing the game\n\nnew_field &lt;- function (size) {\n  dir_path &lt;- here(\"LOGO\", \"temp\")\n  chunk &lt;- 1\n  pos &lt;- 2\n  heading &lt;- 0\n  turtle &lt;- TRUE\n  turtle_color &lt;- \"red\"\n  path_color &lt;- \"blue\"\n  speed &lt;- 50\n  path &lt;- data.frame(\n    chunk = rep(1, pos),\n    x = rep(0, pos),\n    y = rep(0, pos),\n    rad = rep(0, pos),\n    path_color = rep(\"transparent\", pos),\n    turtle = c(FALSE, rep(turtle, pos - 1)),\n    turtle_color = rep(turtle_color, pos),\n    stringsAsFactors = FALSE\n  )\n  \n  LOGO$field_name = \"LOGO\"\n  LOGO$field_dir = here()\n  LOGO$size = abs(size)\n  LOGO$chunk = chunk\n  LOGO$pos = pos\n  LOGO$heading = heading\n  LOGO$turtle = turtle\n  LOGO$turtle_color = turtle_color\n  LOGO$path_color = path_color\n  LOGO$speed = speed\n  LOGO$path = path\n}\n\n\n\n record_path &lt;- function (chunk = NULL,\n                          x = NULL, \n                          y = NULL, \n                          rad = NULL, \n                          path_color = NULL, \n                          turtle = NULL,\n                          turtle_color = NULL) {\n   \n   n &lt;- max(length(x),1)\n   template &lt;- LOGO$path[LOGO$pos, ]\n   \n   if (n &gt; 1) {\n     newrows &lt;- template[rep(1,n), ]\n     new_pos &lt;- LOGO$pos + (1:n)\n   } else {\n     newrows &lt;- template\n     new_pos &lt;- LOGO$pos + 1\n   }\n   \n   \n   if (!is.null(chunk)) newrows$chunk &lt;- chunk\n   if (!is.null(x)) newrows$x &lt;- x\n   if (!is.null(y)) newrows$y &lt;- y\n   if (!is.null(rad)) newrows$rad &lt;- rad\n   if (!is.null(path_color)) newrows$path_color &lt;- path_color\n   if (!is.null(turtle)) newrows$turtle &lt;- turtle\n   if (!is.null(turtle_color)) newrows$turtle_color &lt;- turtle_color\n   \n   LOGO$path[new_pos,] &lt;- newrows\n   LOGO$pos &lt;- nrow(LOGO$path)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#plot-functions",
    "href": "LOGO_Hubi.html#plot-functions",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "plot_field &lt;- function (stat) {\n  maxpath &lt;- ceiling(max(abs(LOGO$path[1:stat,c(\"x\",\"y\")])) * 1.11)\n  LOGO$size &lt;- max(c(LOGO$size, maxpath), na.rm = TRUE)\n\n  par(mar = c(0, 0, 0, 0),\n      xaxs = \"i\", yaxs = \"i\")\n  plot.new()\n  plot.window(xlim = c(-LOGO$size, LOGO$size),\n              ylim = c(-LOGO$size, LOGO$size),\n              asp = 1)\n  box()\n}\n\n\n\nplot_path &lt;- function (stat) {\n  if (stat &gt; 1) {\n    path_stat &lt;- LOGO$path[1:stat,]\n    segments(x0 = path_stat$x[-stat], \n             y0 = path_stat$y[-stat],\n             x1 = path_stat$x[-1], \n             y1 = path_stat$y[-1],\n             col = path_stat$path_color[-1], \n             lwd = 2)\n  }\n}\n\n\n\nplot_turtle &lt;- function (stat) {\n  show &lt;-  LOGO$path$turtle[stat]\n  if (show) {\n    pos_x &lt;- LOGO$path$x[stat]\n    pos_y &lt;- LOGO$path$y[stat]\n    symbols(x = pos_x,\n            y = pos_y,\n            circles = 0.02 * LOGO$size,\n            inches = FALSE,\n            fg = NA,\n            bg = LOGO$path$turtle_color[stat],\n            add = TRUE)\n    arrow_length &lt;- 0.1 * LOGO$size\n    angle &lt;- LOGO$path$rad[stat]\n    arrows(pos_x,\n           pos_y,\n           pos_x + cos(angle) * arrow_length,\n           pos_y + sin(angle) * arrow_length,\n           col = LOGO$path$turtle_color[stat],\n           code = 2,\n           length = 0.1,\n           angle = 20,\n           lwd = 2)\n  }\n}\n\n\n\nplot_stat &lt;- function (stat = NULL) {\n  if(is.null(stat)) stat &lt;- nrow(LOGO$path)\n  \n  tmpfile &lt;- tempfile(fileext = \".png\")\n  png(filename = tmpfile, width = 600, height = 600, res = 150)\n  \n  plot_field(stat)\n  plot_path(stat)\n  plot_turtle(stat)\n  \n  dev.off()\n  img &lt;- image_read(tmpfile)\n  \n  unlink(tmpfile)\n\n  img\n\n}\n\n\n\nPLOT &lt;- function (chunk = TRUE) {\n  invisible(NULL)\n  \n  if (chunk) {\n    Range &lt;- range(which(LOGO$path$chunk == max(LOGO$chunk)))\n    rmin &lt;- max(2,Range[1])\n    rmax &lt;- Range[2]\n    } else {\n      rmin &lt;- 2\n      rmax &lt;- nrow(LOGO$path)\n    }\n  \n  step &lt;- LOGO$speed/(rmax-rmin)\n  step &lt;- pmin(pmax(step, 1/200), 1)\n  Seq0 &lt;- seq(from = 0, to = 1, by = step)\n  plot_seq &lt;- qbeta(Seq0, shape1 = 0.15, shape2 = 0.2)\n  plot_seq &lt;- (rmax - rmin) * plot_seq + rmin\n  plot_seq &lt;- round(plot_seq)\n  plot_seq &lt;- unique(plot_seq)\n  \n  img_list &lt;- lapply(plot_seq, function(i) plot_stat(i))\n  Logo_Output &lt;- image_animate(image_join(img_list), \n                             fps = 10, loop = 1,\n                             optimize = TRUE) \n  \n  gif_path &lt;- file.path(tempdir(), \"Logo_Output.gif\")\n  image_write(Logo_Output, path = gif_path)\n  \n  print(Logo_Output)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#application",
    "href": "LOGO_Hubi.html#application",
    "title": "Logo with Gimmicks",
    "section": "",
    "text": "run_LOGO &lt;- function(string) {\n  if (!exists(\"LOGO\", envir = .GlobalEnv)) {\n    assign(\"LOGO\", new.env(), envir = .GlobalEnv)\n    LOGO &lt;- get(\"LOGO\", envir = .GlobalEnv)\n    new_field(5)\n  } else {\n    LOGO &lt;- get(\"LOGO\", envir = .GlobalEnv)\n  }\n  run_prompt(string)\n}"
  },
  {
    "objectID": "LOGO_Hubi.html#example-from-the-homepage",
    "href": "LOGO_Hubi.html#example-from-the-homepage",
    "title": "Logo with Gimmicks",
    "section": "Example from the homepage",
    "text": "Example from the homepage\nwith some fancy shadow and color effects\n\nrun_LOGO(\"CS SP [-pi/5] [-Sin(PI/2)/2] sPc [black]\")\nrun_LOGO(\"REPEAT 20 [RepeaT 180 [FD 1 RT 2] RT 18]\")\nrun_LOGO(\"SPEED 100\")\nrun_LOGO(\"Home SpC [gREEN] StC [blue]\")\nrun_LOGO(\"REPEaT 20.1 [rEPEAT 180 [fD 1 RT 2] RT 18]\")\nrun_LOGO(\"UndoChunk\")\nrun_LOGO(\"SpC [blue] StC [green]\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [green] StC [red] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [yellow] rt 18\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 180 [fD 1 RT 2] RT 72]\")\nrun_LOGO(\"SpC [red] rt 18 ht\")\nrun_LOGO(\"REPEaT 5 [rEPEAT 360 [fD 0.5 RT 1] RT 72]\")\n\nSaved Output\nyou can also save the output (Plot) for showing it around later\n\nrun_LOGO(\"SPEED 1 saVe [Logo01]\")"
  },
  {
    "objectID": "LOGO_Hubi.html#other-exercises",
    "href": "LOGO_Hubi.html#other-exercises",
    "title": "Logo with Gimmicks",
    "section": "Other Exercises",
    "text": "Other Exercises\nSince n is also used as a loop variable in my program, handling many other exercises doesn’t pose any issues.\nhttps://softwareprogramming4kids.com/loops-in-logo/\nExercise 1:\n\nrun_LOGO(\"CS\")\nrun_LOGO(\"REPEAT 80 [FD [N*2] RT 90]\")\nrun_LOGO(\"undo\")\nrun_LOGO(\"REPEAT 80 [FD [N*2^(N/40)] RT 90]\")\n\n\nrun_LOGO(\"SPEED 1 saVe [Logo02]\")\n\n\nExercise 2:\n\nrun_LOGO(\"CS REPEAT 50 [ FD [n * 5]  RIGHT 144 ]\")\n\n\nrun_LOGO(\"SPEED 1 saVe [Logo03]\")\n\n\nExercise 3:\n\nrun_LOGO(\"CS REPEAT 150 [ FD [n * 2]  RT 91 ]\")\n\n\nrun_LOGO(\"SPEED 1 saVe [Logo04]\")"
  },
  {
    "objectID": "LOGO_Hubi.html#testing-back",
    "href": "LOGO_Hubi.html#testing-back",
    "title": "Logo with Gimmicks",
    "section": "Testing Back",
    "text": "Testing Back\n\nrun_LOGO(\"CS\")\n\n# A tibble: 1 × 7\n  format width height colorspace matte filesize density\n  &lt;chr&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;      &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;  \n1 gif      600    600 sRGB       FALSE        0 59x59  \n\nrun_LOGO(\"SPEED 1\")\nrun_LOGO(\"FD 200 lt 90 fd 50 lt 90\")\n\n# A tibble: 82 × 7\n   format width height colorspace matte filesize density\n   &lt;chr&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;      &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;  \n 1 gif      600    600 sRGB       FALSE        0 59x59  \n 2 gif        1      1 sRGB       TRUE         0 59x59  \n 3 gif        1      1 sRGB       TRUE         0 59x59  \n 4 gif        1      1 sRGB       TRUE         0 59x59  \n 5 gif        1      1 sRGB       TRUE         0 59x59  \n 6 gif       39     13 sRGB       FALSE        0 59x59  \n 7 gif        1      1 sRGB       TRUE         0 59x59  \n 8 gif        1      1 sRGB       TRUE         0 59x59  \n 9 gif        1      1 sRGB       TRUE         0 59x59  \n10 gif        1      1 sRGB       TRUE         0 59x59  \n# ℹ 72 more rows\n\nrun_LOGO(\"FD 400 \")\n\n# A tibble: 102 × 7\n   format width height colorspace matte filesize density\n   &lt;chr&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;      &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;  \n 1 gif      600    600 sRGB       FALSE        0 59x59  \n 2 gif        1      1 sRGB       TRUE         0 59x59  \n 3 gif        1      1 sRGB       TRUE         0 59x59  \n 4 gif        1      1 sRGB       TRUE         0 59x59  \n 5 gif        1      1 sRGB       TRUE         0 59x59  \n 6 gif        1      1 sRGB       TRUE         0 59x59  \n 7 gif        1      1 sRGB       TRUE         0 59x59  \n 8 gif        1      1 sRGB       TRUE         0 59x59  \n 9 gif        1      1 sRGB       TRUE         0 59x59  \n10 gif        1      1 sRGB       TRUE         0 59x59  \n# ℹ 92 more rows\n\nrun_LOGO(\"rt 90 fd 50 lt 90\")\n\n# A tibble: 18 × 7\n   format width height colorspace matte filesize density\n   &lt;chr&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;      &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;  \n 1 gif      600    600 sRGB       FALSE        0 59x59  \n 2 gif       38     38 sRGB       FALSE        0 59x59  \n 3 gif        1      1 sRGB       TRUE         0 59x59  \n 4 gif        1      1 sRGB       TRUE         0 59x59  \n 5 gif        1      1 sRGB       TRUE         0 59x59  \n 6 gif        1      1 sRGB       TRUE         0 59x59  \n 7 gif        1      1 sRGB       TRUE         0 59x59  \n 8 gif       14     38 sRGB       FALSE        0 59x59  \n 9 gif       14     44 sRGB       FALSE        0 59x59  \n10 gif       14     52 sRGB       FALSE        0 59x59  \n11 gif       14     64 sRGB       FALSE        0 59x59  \n12 gif       14     49 sRGB       FALSE        0 59x59  \n13 gif       14     41 sRGB       FALSE        0 59x59  \n14 gif       14     38 sRGB       FALSE        0 59x59  \n15 gif        1      1 sRGB       TRUE         0 59x59  \n16 gif        1      1 sRGB       TRUE         0 59x59  \n17 gif        1      1 sRGB       TRUE         0 59x59  \n18 gif       38     38 sRGB       FALSE        0 59x59  \n\nrun_LOGO(\"bk 400\")\n\n# A tibble: 102 × 7\n   format width height colorspace matte filesize density\n   &lt;chr&gt;  &lt;int&gt;  &lt;int&gt; &lt;chr&gt;      &lt;lgl&gt;    &lt;int&gt; &lt;chr&gt;  \n 1 gif      600    600 sRGB       FALSE        0 59x59  \n 2 gif        1      1 sRGB       TRUE         0 59x59  \n 3 gif        1      1 sRGB       TRUE         0 59x59  \n 4 gif        1      1 sRGB       TRUE         0 59x59  \n 5 gif        1      1 sRGB       TRUE         0 59x59  \n 6 gif        1      1 sRGB       TRUE         0 59x59  \n 7 gif        1      1 sRGB       TRUE         0 59x59  \n 8 gif        1      1 sRGB       TRUE         0 59x59  \n 9 gif        1      1 sRGB       TRUE         0 59x59  \n10 gif        1      1 sRGB       TRUE         0 59x59  \n# ℹ 92 more rows"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Goal",
    "section": "",
    "text": "Logo goes back much earlier than the Apple II, it was developed in 1967 by Cynthia Solomon, Wally Feurzig, and Seymour Papert. That’s five years before C and 24 years before Python! The three worked at Bolt, Beranek, and Newman (BBN), famous for all kinds of other computing history. BBN built the first Interface Message Processors (early routers) in 1968 for the ARPANET, which would evolve into the modern internet. …learn more\n\n\nOverview of some turtle commands and their shorthand equivalents:\nCLEARSCREEN - Clear the screen. (Shorthand: CS)\nHIDETURTLE - Don’t show the turtle cursor. (HT)\nSHOWTURTLE - Show the turtle cursor. (ST)\nHOME - Move back to the home position.\nFORWARD steps - Move forward steps. (FD)\nBACK steps - Move back steps. (BK)\nLEFT degrees - Turn left this many degrees. Negative degrees work too, they’ll turn it right. (LT)\nRIGHT degrees - Turn right this many degrees. (RT)\nSETHEADING degrees - Turn to an absolute heading of degrees. (SETH)\nSETPOS [x y] - Set the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\nSETX x - Set the horizontal position to x.\nSETY y - Set the vertical position to y.\n\n\n\nGenerate this code-Line with your own Logo-Code:\nREPEAT 20 [REPEAT 180 [FD 1 RT 2] RT 18]"
  },
  {
    "objectID": "index.html#commands",
    "href": "index.html#commands",
    "title": "Goal",
    "section": "",
    "text": "Overview of some turtle commands and their shorthand equivalents:\nCLEARSCREEN - Clear the screen. (Shorthand: CS)\nHIDETURTLE - Don’t show the turtle cursor. (HT)\nSHOWTURTLE - Show the turtle cursor. (ST)\nHOME - Move back to the home position.\nFORWARD steps - Move forward steps. (FD)\nBACK steps - Move back steps. (BK)\nLEFT degrees - Turn left this many degrees. Negative degrees work too, they’ll turn it right. (LT)\nRIGHT degrees - Turn right this many degrees. (RT)\nSETHEADING degrees - Turn to an absolute heading of degrees. (SETH)\nSETPOS [x y] - Set the position to x, y coordinates. These are Cartesian, so 0,0 is the middle of the screen.\nSETX x - Set the horizontal position to x.\nSETY y - Set the vertical position to y."
  },
  {
    "objectID": "index.html#planed-result",
    "href": "index.html#planed-result",
    "title": "Goal",
    "section": "",
    "text": "Generate this code-Line with your own Logo-Code:\nREPEAT 20 [REPEAT 180 [FD 1 RT 2] RT 18]"
  }
]